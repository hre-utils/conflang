#!/bin/bash
#
# TODO:
# Global ERROR flag to mark as TRUE, so we can exit if something has failed in
# one of the redirection subshells. Set up a `trap` at the top of each script
# to set ERROR on failures. Can bail and not continue the whole compilation
# chain if something has gone awry.


declare -g PROGDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" ; pwd )
declare -g INPUT="$1"

if [[ -z "$INPUT" ]] ; then
   echo "Requires file input" 1>&2
   exit -1
fi

#source "${PROGDIR}/errors.sh"

#declare -a ERRORS=()
#declare -A COMPILE_ERROR=(
#   # All errors are defined in the ./errors.sh file. Easier to define them in a
#   # single place, both for lookup, and ensuring the same exit status isn't used
#   # twice.
#   [SYNTAX_ERROR]=${COMPILE_ERROR__SYNTAX_ERROR}
#)

# This toomfoolery is just to isolate all the functions/variables to each
# respective file. Particularly as the lexer/parser reuse function names like
#  `advance`, `current`, etc.
# Only the particular information we *want* to export is.
source <(
   source <( "${PROGDIR}"/lexer.sh "$INPUT" )
   # Exports:
   #  TOKENS[]             # Array of token names
   #  TOKEN_$n             # Sequence of all token objects
   #  INPUT_FILE           # Name of input file
   #  FILE_LINES[]         # INPUT_FILE.readlines()

   source "${PROGDIR}"/parser.sh
   # Exports:
   #  ROOT
   #  TYPEOF{}
   #  NODE_*
)

source "${PROGDIR}"/compiler.sh
# Exports (USER ACCESSIBLE):
#  _DATA_ROOT
#  _DATA_*

source "${PROGDIR}"/api.sh
# Exports (USER ACCESSIBLE):
#  RV
#  conf()

# Example usage:
#conf global one ; echo "$RV"
